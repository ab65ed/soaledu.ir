const Parse = require('parse/node');
import { QuestionOptions } from '../types/interfaces';
import Question from '../models/Question';
import { validationResult } from 'express-validator';

/**
 * Question Controller
 * کنترلر مدیریت سوالات با قابلیت ذخیره لحظه‌ای و اعتبارسنجی
 * 
 * ویژگی‌های اصلی:
 * - CRUD کامل سوالات
 * - ذخیره لحظه‌ای (Auto-save)
 * - جستجوی پیشرفته
 * - اعتبارسنجی 4 گزینه
 * - صفحه منبع اختیاری
 */

class QuestionController {
  /**
   * Create a new question
   * POST /api/questions
   */
  static async create(req, res) {
    try {
      // Validation check
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'خطاهای اعتبارسنجی',
          errors: errors.array().map(err => ({
            field: err.param,
            message: err.msg
          }))
        });
      }

      const questionData = {
        ...req.body,
        authorId: req.user.id,
        author: req.user
      };

      const question = await Question.create(questionData);

      res.status(201).json({
        success: true,
        message: 'سوال با موفقیت ایجاد شد',
        data: question.toJSON()
      });

    } catch (error) {
      console.error('Error creating question:', error);
      res.status(500).json({
        success: false,
        message: 'خطا در ایجاد سوال',
        error: error.message
      });
    }
  }

  /**
   * Get all questions with filtering and pagination
   * GET /api/questions
   */
  static async list(req, res) {
    try {
      const {
        page = 1,
        limit = 10,
        type,
        category,
        difficulty,
        tags,
        search,
        sortBy = 'newest',
        publishedOnly = 'true',
        authorId
      } = req.query;

      const options: QuestionOptions = {
        limit: parseInt(limit),
        skip: (parseInt(page) - 1) * parseInt(limit),
        type,
        category,
        difficulty,
        sortBy,
        search
      };

      if (tags) {
        options.tags = Array.isArray(tags) ? tags : tags.split(',');
      }

      let questions;
      if (publishedOnly === 'true') {
        questions = await Question.findPublished(options);
      } else if (authorId) {
        questions = await Question.findByAuthor(authorId, options);
      } else {
        // Admin or special access
        const query = new Parse.Query(Question);
        
        if (options.type) query.equalTo('type', options.type);
        if (options.category) query.equalTo('category', options.category);
        if (options.difficulty) query.equalTo('difficulty', options.difficulty);
        if (options.tags) query.containedIn('tags', options.tags);
        
        if (options.search) {
          const textQuery = new Parse.Query(Question);
          textQuery.contains('text', options.search);
          
          const categoryQuery = new Parse.Query(Question);
          categoryQuery.contains('category', options.search);
          
          const searchQuery = Parse.Query.or(textQuery, categoryQuery);
          query = Parse.Query.and(query, searchQuery);
        }
        
        query.limit(options.limit);
        query.skip(options.skip);
        query.descending('createdAt');
        
        questions = await query.find();
      }

      // Get total count for pagination
      const totalQuery = new Parse.Query(Question);
      if (publishedOnly === 'true') {
        totalQuery.equalTo('isPublished', true);
      }
      if (authorId) {
        totalQuery.equalTo('authorId', authorId);
      }
      
      const totalCount = await totalQuery.count();
      const totalPages = Math.ceil(totalCount / parseInt(limit));

      res.json({
        success: true,
        data: questions.map(q => q.toJSON()),
        pagination: {
          currentPage: parseInt(page),
          totalPages,
          totalCount,
          hasNext: parseInt(page) < totalPages,
          hasPrev: parseInt(page) > 1
        }
      });

    } catch (error) {
      console.error('Error listing questions:', error);
      res.status(500).json({
        success: false,
        message: 'خطا در دریافت لیست سوالات',
        error: error.message
      });
    }
  }

  /**
   * Get a single question by ID
   * GET /api/questions/:id
   */
  static async getById(req, res) {
    try {
      const { id } = req.params;
      const question = await Question.findById(id);

      if (!question) {
        return res.status(404).json({
          success: false,
          message: 'سوال یافت نشد'
        });
      }

      // Check access permissions
      if (!question.isPublished && question.authorId !== req.user?.id) {
        return res.status(403).json({
          success: false,
          message: 'دسترسی غیرمجاز'
        });
      }

      res.json({
        success: true,
        data: question.toJSON()
      });

    } catch (error) {
      console.error('Error getting question:', error);
      res.status(500).json({
        success: false,
        message: 'خطا در دریافت سوال',
        error: error.message
      });
    }
  }

  /**
   * Update a question
   * PUT /api/questions/:id
   */
  static async update(req, res) {
    try {
      // Validation check
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'خطاهای اعتبارسنجی',
          errors: errors.array().map(err => ({
            field: err.param,
            message: err.msg
          }))
        });
      }

      const { id } = req.params;
      const question = await Question.findById(id);

      if (!question) {
        return res.status(404).json({
          success: false,
          message: 'سوال یافت نشد'
        });
      }

      // Check ownership
      if (question.authorId !== req.user.id) {
        return res.status(403).json({
          success: false,
          message: 'فقط سازنده سوال می‌تواند آن را ویرایش کند'
        });
      }

      // Update fields
      Object.keys(req.body).forEach(key => {
        if (question.hasOwnProperty(key)) {
          question[key] = req.body[key];
        }
      });

      // Update metadata
      const currentMetadata = question.metadata || {};
      question.metadata = {
        ...currentMetadata,
        lastUpdate: new Date(),
        version: (currentMetadata.version || 0) + 1
      };

      await question.save();

      res.json({
        success: true,
        message: 'سوال با موفقیت به‌روزرسانی شد',
        data: question.toJSON()
      });

    } catch (error) {
      console.error('Error updating question:', error);
      res.status(500).json({
        success: false,
        message: 'خطا در به‌روزرسانی سوال',
        error: error.message
      });
    }
  }

  /**
   * Delete a question
   * DELETE /api/questions/:id
   */
  static async delete(req, res) {
    try {
      const { id } = req.params;
      const question = await Question.findById(id);

      if (!question) {
        return res.status(404).json({
          success: false,
          message: 'سوال یافت نشد'
        });
      }

      // Check ownership
      if (question.authorId !== req.user.id) {
        return res.status(403).json({
          success: false,
          message: 'فقط سازنده سوال می‌تواند آن را حذف کند'
        });
      }

      await question.destroy();

      res.json({
        success: true,
        message: 'سوال با موفقیت حذف شد'
      });

    } catch (error) {
      console.error('Error deleting question:', error);
      res.status(500).json({
        success: false,
        message: 'خطا در حذف سوال',
        error: error.message
      });
    }
  }

  /**
   * Auto-save question (real-time save)
   * PATCH /api/questions/:id/auto-save
   */
  static async autoSave(req, res) {
    try {
      const { id } = req.params;
      
      // For new questions, create a draft
      if (id === 'new') {
        const questionData = {
          ...req.body,
          authorId: req.user.id,
          author: req.user,
          isDraft: true,
          isPublished: false
        };

        const question = await Question.create(questionData);

        return res.json({
          success: true,
          message: 'پیش‌نویس ذخیره شد',
          data: question.toJSON(),
          autoSave: true
        });
      }

      const question = await Question.findById(id);

      if (!question) {
        return res.status(404).json({
          success: false,
          message: 'سوال یافت نشد'
        });
      }

      // Check ownership
      if (question.authorId !== req.user.id) {
        return res.status(403).json({
          success: false,
          message: 'دسترسی غیرمجاز'
        });
      }

      await question.autoSave(req.body);

      res.json({
        success: true,
        message: 'تغییرات به صورت خودکار ذخیره شد',
        data: question.toJSON(),
        autoSave: true,
        lastAutoSave: question.lastAutoSave
      });

    } catch (error) {
      console.error('Error auto-saving question:', error);
      res.status(500).json({
        success: false,
        message: 'خطا در ذخیره خودکار',
        error: error.message,
        autoSave: false
      });
    }
  }

  /**
   * Publish a question
   * PATCH /api/questions/:id/publish
   */
  static async publish(req, res) {
    try {
      const { id } = req.params;
      const question = await Question.findById(id);

      if (!question) {
        return res.status(404).json({
          success: false,
          message: 'سوال یافت نشد'
        });
      }

      // Check ownership
      if (question.authorId !== req.user.id) {
        return res.status(403).json({
          success: false,
          message: 'فقط سازنده سوال می‌تواند آن را منتشر کند'
        });
      }

      await question.publish();

      res.json({
        success: true,
        message: 'سوال با موفقیت منتشر شد',
        data: question.toJSON()
      });

    } catch (error) {
      console.error('Error publishing question:', error);
      res.status(400).json({
        success: false,
        message: 'خطا در انتشار سوال',
        error: error.message
      });
    }
  }

  /**
   * Unpublish a question
   * PATCH /api/questions/:id/unpublish
   */
  static async unpublish(req, res) {
    try {
      const { id } = req.params;
      const question = await Question.findById(id);

      if (!question) {
        return res.status(404).json({
          success: false,
          message: 'سوال یافت نشد'
        });
      }

      // Check ownership
      if (question.authorId !== req.user.id) {
        return res.status(403).json({
          success: false,
          message: 'فقط سازنده سوال می‌تواند آن را از انتشار خارج کند'
        });
      }

      await question.unpublish();

      res.json({
        success: true,
        message: 'سوال از انتشار خارج شد',
        data: question.toJSON()
      });

    } catch (error) {
      console.error('Error unpublishing question:', error);
      res.status(500).json({
        success: false,
        message: 'خطا در خروج از انتشار',
        error: error.message
      });
    }
  }

  /**
   * Search questions
   * GET /api/questions/search
   */
  static async search(req, res) {
    try {
      const {
        q: searchText,
        limit = 20,
        publishedOnly = 'true'
      } = req.query;

      if (!searchText || searchText.trim().length < 2) {
        return res.status(400).json({
          success: false,
          message: 'متن جستجو باید حداقل ۲ کاراکتر باشد'
        });
      }

      const options = {
        limit: parseInt(limit),
        publishedOnly: publishedOnly === 'true'
      };

      const questions = await Question.searchByText(searchText.trim(), options);

      res.json({
        success: true,
        data: questions.map(q => q.toJSON()),
        searchText: searchText.trim(),
        resultCount: questions.length
      });

    } catch (error) {
      console.error('Error searching questions:', error);
      res.status(500).json({
        success: false,
        message: 'خطا در جستجو',
        error: error.message
      });
    }
  }

  /**
   * Get question statistics
   * GET /api/questions/stats
   */
  static async getStats(req, res) {
    try {
      const { authorId } = req.query;
      
      // If authorId is provided, check if it's the current user or admin
      if (authorId && authorId !== req.user?.id && !req.user?.isAdmin) {
        return res.status(403).json({
          success: false,
          message: 'دسترسی غیرمجاز'
        });
      }

      const stats = await Question.getStats(authorId || req.user?.id);

      res.json({
        success: true,
        data: stats
      });

    } catch (error) {
      console.error('Error getting question stats:', error);
      res.status(500).json({
        success: false,
        message: 'خطا در دریافت آمار',
        error: error.message
      });
    }
  }

  /**
   * Get available tags
   * GET /api/questions/tags
   */
  static async getTags(req, res) {
    try {
      const { limit = 50, search } = req.query;

      const query = new Parse.Query(Question);
      query.equalTo('isPublished', true);
      query.select('tags');
      query.limit(1000); // Get more questions to extract tags

      const questions = await query.find();
      
      // Extract all tags
      const allTags = questions.reduce((tags, question) => {
        const questionTags = question.get('tags') || [];
        return [...tags, ...questionTags];
      }, []);

      // Count tag frequency and filter
      const tagCounts = allTags.reduce((counts, tag) => {
        counts[tag] = (counts[tag] || 0) + 1;
        return counts;
      }, {});

      let tags = Object.entries(tagCounts)
        .map(([tag, count]) => ({ tag, count }))
        .sort((a, b) => b.count - a.count);

      // Filter by search if provided
      if (search) {
        tags = tags.filter(({ tag }) => 
          tag.toLowerCase().includes(search.toLowerCase())
        );
      }

      // Limit results
      tags = tags.slice(0, parseInt(limit));

      res.json({
        success: true,
        data: tags
      });

    } catch (error) {
      console.error('Error getting tags:', error);
      res.status(500).json({
        success: false,
        message: 'خطا در دریافت تگ‌ها',
        error: error.message
      });
    }
  }

  /**
   * Get categories
   * GET /api/questions/categories
   */
  static async getCategories(req, res) {
    try {
      const query = new Parse.Query(Question);
      query.equalTo('isPublished', true);
      query.select('category');
      query.limit(1000);

      const questions = await query.find();
      
      const categories = questions.reduce((cats, question) => {
        const category = question.get('category');
        if (category) {
          cats[category] = (cats[category] || 0) + 1;
        }
        return cats;
      }, {});

      const categoryList = Object.entries(categories)
        .map(([category, count]) => ({ category, count }))
        .sort((a, b) => b.count - a.count);

      res.json({
        success: true,
        data: categoryList
      });

    } catch (error) {
      console.error('Error getting categories:', error);
      res.status(500).json({
        success: false,
        message: 'خطا در دریافت دسته‌بندی‌ها',
        error: error.message
      });
    }
  }

  /**
   * Validate question data
   * POST /api/questions/validate
   */
  static async validate(req, res) {
    try {
      const tempQuestion = new Question();
      
      // Set data without saving
      Object.keys(req.body).forEach(key => {
        if (tempQuestion.hasOwnProperty(key)) {
          tempQuestion[key] = req.body[key];
        }
      });

      const validation = tempQuestion.validate();

      res.json({
        success: true,
        data: {
          isValid: validation.isValid,
          errors: validation.errors
        }
      });

    } catch (error) {
      console.error('Error validating question:', error);
      res.status(500).json({
        success: false,
        message: 'خطا در اعتبارسنجی',
        error: error.message
      });
    }
  }

  /**
   * Duplicate a question
   * POST /api/questions/:id/duplicate
   */
  static async duplicate(req, res) {
    try {
      const { id } = req.params;
      const originalQuestion = await Question.findById(id);

      if (!originalQuestion) {
        return res.status(404).json({
          success: false,
          message: 'سوال یافت نشد'
        });
      }

      // Check access to original question
      if (!originalQuestion.isPublished && originalQuestion.authorId !== req.user.id) {
        return res.status(403).json({
          success: false,
          message: 'دسترسی غیرمجاز'
        });
      }

      // Create duplicate
      const duplicateData = {
        type: originalQuestion.type,
        text: `${originalQuestion.text} (کپی)`,
        options: [...originalQuestion.options],
        correctOptions: [...originalQuestion.correctOptions],
        correctAnswer: originalQuestion.correctAnswer,
        allowMultipleCorrect: originalQuestion.allowMultipleCorrect,
        difficulty: originalQuestion.difficulty,
        points: originalQuestion.points,
        explanation: originalQuestion.explanation,
        category: originalQuestion.category,
        lesson: originalQuestion.lesson,
        tags: [...originalQuestion.tags],
        timeLimit: originalQuestion.timeLimit,
        sourcePage: originalQuestion.sourcePage,
        sourceBook: originalQuestion.sourceBook,
        sourceChapter: originalQuestion.sourceChapter,
        isDraft: true,
        isPublished: false,
        authorId: req.user.id,
        author: req.user
      };

      const duplicateQuestion = await Question.create(duplicateData);

      res.status(201).json({
        success: true,
        message: 'سوال با موفقیت کپی شد',
        data: duplicateQuestion.toJSON()
      });

    } catch (error) {
      console.error('Error duplicating question:', error);
      res.status(500).json({
        success: false,
        message: 'خطا در کپی کردن سوال',
        error: error.message
      });
    }
  }
}

export default QuestionController; 